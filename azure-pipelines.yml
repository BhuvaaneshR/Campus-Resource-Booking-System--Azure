trigger:
  branches:
    include:
      - main

# Optional: run on PRs to main too (remove if you don't want PR validation)
pr:
  branches:
    include:
      - main

# ================== VARIABLES ==================
variables:
  # 1) Library > Variable Group (must exist in Pipelines > Library)
  - group: CampusResourceBookingVariableGroup   # SONAR_TOKEN (secret), sonarOrganization, sonarProjectKey, sonarProjectName

  # 2) Name/value vars for infra & CI/CD
  - name: acrName
    value: 'campusbookingacr'                     # <--- EDIT if needed
  - name: resourceGroup
    value: 'campusbookingrg'                      # (kept for reference; not used directly here)
  - name: backendAppName
    value: 'campus-booking-backend-api'           # <--- EDIT
  - name: frontendAppName
    value: 'campus-booking-frontend-web'          # <--- EDIT
  - name: backendUrl
    value: 'https://campus-booking-backend-api.azurewebsites.net/api'  # <--- EDIT (frontend env)
  - name: azureSubscription
    value: 'azure-students-connection'            # <--- EDIT (Service Connection display name)
  - name: SCANNER_VER
    value: '6.2.1.4610'

  # Service connection to ACR used by Docker@2 tasks
  - name: acrServiceConnection
    value: 'campusbookingacr-connection'          # <--- EDIT (Service Connection to your ACR)

  # Trivy
  - name: trivy_version
    value: '0.67.2'

# ================== STAGES ==================
stages:

# ========== STAGE 0: CODE SCAN (SAST + secrets + SonarCloud) ==========
- stage: CodeScan
  displayName: 'Static & Secrets Analysis'
  jobs:
    - job: CodeQuality
      displayName: 'Secrets + Dependencies + SonarCloud'
      pool:
        vmImage: 'ubuntu-latest'
      steps:
        # Ensure full history so Gitleaks can scan properly
        - checkout: self
          fetchDepth: 0

        # ---- Gitleaks (release binary) + report artifact (SOFT-FAIL) ----
        - script: |
            set -euo pipefail
            REPORT_DIR="$(System.DefaultWorkingDirectory)/security-reports"
            mkdir -p "$REPORT_DIR"

            GL_VER="8.18.3"
            TARBALL="gitleaks_${GL_VER}_linux_x64.tar.gz"
            URL="https://github.com/gitleaks/gitleaks/releases/download/v${GL_VER}/${TARBALL}"

            echo "Downloading Gitleaks v${GL_VER}..."
            curl -fsSL "$URL" -o "$TARBALL"

            echo "Extracting..."
            tar -xzf "$TARBALL" gitleaks
            chmod +x gitleaks

            echo "Running Gitleaks (soft-fail)..."
            ./gitleaks detect \
              --source "$(System.DefaultWorkingDirectory)" \
              --no-banner \
              --redact \
              --report-format json \
              --report-path "$REPORT_DIR/gitleaks_report.json" \
              --exit-code 0
          displayName: 'Gitleaks (secrets scan) — soft fail'

        - task: PublishBuildArtifacts@1
          displayName: 'Publish Gitleaks report'
          condition: always()
          inputs:
            PathtoPublish: '$(System.DefaultWorkingDirectory)/security-reports'
            ArtifactName: 'security-reports'

        # ---- Node setup ----
        - task: NodeTool@0
          displayName: 'Use Node 20.x'
          inputs:
            versionSpec: '20.x'

        # ---- TEMPORARY: Fix known vulnerabilities before build ----
        - bash: |
            set -e
            cd backend
            echo "Checking and fixing known vulnerabilities..."
            
            # Fix CVE-2024-21538 (cross-spawn)
            if grep -q '"cross-spawn": "7.0.3"' package-lock.json 2>/dev/null; then
              echo "Updating cross-spawn to 7.0.5 (CVE-2024-21538)..."
              npm install cross-spawn@7.0.5 --save-exact
            fi
            
            # Run general audit fix
            npm audit fix --force || true
            
            echo "✓ Vulnerability fixes applied"
          displayName: 'Auto-fix Known Vulnerabilities'
          continueOnError: true

        # ---- Build (so analyzers see TS outputs if needed) ----
        - script: |
            set -e
            cd backend
            npm ci --no-audit --no-fund
            npm run build
          displayName: 'Build backend (tsc)'

        - script: |
            set -e
            cd frontend
            npm ci --no-audit --no-fund
            npm run build
          displayName: 'Build frontend (tsc)'

        # ---- Dependency audit (soft fail) ----
        - script: |
            set -e
            cd backend
            npm audit --audit-level=high || true
            cd ../frontend
            npm audit --audit-level=high || true
          displayName: 'Dependency audit (npm) — soft fail'

        # ---- SonarCloud via CLI ----
        - task: Bash@3
          displayName: 'Install & run SonarScanner (CLI)'
          env:
            SONAR_TOKEN: $(SONAR_TOKEN)             # from Variable Group (secret)
            SONAR_ORG: $(sonarOrganization)         # from Variable Group
            SONAR_PROJECT_KEY: $(sonarProjectKey)   # from Variable Group
            SONAR_PROJECT_NAME: $(sonarProjectName) # from Variable Group
            SCANNER_VER: $(SCANNER_VER)             # optional override
          inputs:
            targetType: 'inline'
            script: |
              set -euo pipefail
              : "${SONAR_TOKEN:?SONAR_TOKEN is not set}"
              : "${SONAR_ORG:?SONAR_ORG is not set}"
              : "${SONAR_PROJECT_KEY:?SONAR_PROJECT_KEY is not set}"
              : "${SONAR_PROJECT_NAME:?SONAR_PROJECT_NAME is not set}"

              VER="${SCANNER_VER:-6.2.1.4610}"
              if [[ "$VER" == 5.* ]]; then
                ZIP="sonar-scanner-cli-${VER}-linux.zip"
                DIR="sonar-scanner-${VER}-linux"
              else
                ZIP="sonar-scanner-cli-${VER}-linux-x64.zip"
                DIR="sonar-scanner-${VER}-linux-x64"
              fi

              URL_PRIMARY="https://binaries.sonarsource.com/Distribution/sonar-scanner-cli/${ZIP}"
              URL_FALLBACK="https://get.sonarsource.org/sonar-scanner-cli/${ZIP}"

              echo "Downloading SonarScanner CLI ${VER}..."
              if ! curl -fsSLo "$ZIP" "$URL_PRIMARY"; then
                echo "Primary download failed; trying fallback..."
                curl -fsSLo "$ZIP" "$URL_FALLBACK"
              fi

              echo "Unzipping..."
              unzip -q "$ZIP"

              SCANNER_DIR="$PWD/${DIR}"
              export PATH="$SCANNER_DIR/bin:$PATH"

              echo "SonarScanner version:"
              sonar-scanner --version

              sonar-scanner \
                -Dsonar.host.url=https://sonarcloud.io \
                -Dsonar.organization="${SONAR_ORG}" \
                -Dsonar.projectKey="${SONAR_PROJECT_KEY}" \
                -Dsonar.projectName="${SONAR_PROJECT_NAME}" \
                -Dsonar.sources=. \
                -Dsonar.exclusions=**/node_modules/**,**/dist/**,**/build/**,**/.next/**,**/.terraform/** \
                -Dsonar.token="${SONAR_TOKEN}"

        # ---- Enforce Sonar Quality Gate (poll for result) ----
        - task: Bash@3
          displayName: 'Fail if Sonar Quality Gate fails'
          env:
            SONAR_TOKEN: $(SONAR_TOKEN)
            SONAR_PROJECT_KEY: $(sonarProjectKey)
          inputs:
            targetType: 'inline'
            script: |
              set -euo pipefail
              apt-get update -y >/dev/null 2>&1 || true
              apt-get install -y jq >/dev/null 2>&1 || true

              echo "Polling SonarCloud Quality Gate for project: ${SONAR_PROJECT_KEY}"
              for i in {1..12}; do
                RES=$(curl -s -u "${SONAR_TOKEN}:" \
                  "https://sonarcloud.io/api/qualitygates/project_status?projectKey=${SONAR_PROJECT_KEY}" || true)
                STATUS=$(echo "$RES" | jq -r '.projectStatus.status // empty')
                if [[ -n "$STATUS" && "$STATUS" != "IN_PROGRESS" ]]; then
                  echo "Quality Gate: $STATUS"
                  [[ "$STATUS" == "OK" ]] && exit 0 || exit 1
                fi
                echo "Quality Gate still computing... retry $i"
                sleep 10
              done
              echo "Quality Gate did not return a final status in time."
              exit 1

        # ---- Trivy filesystem scan (repo) — non-blocking + SARIF ----
        - task: Cache@2
          displayName: 'Cache Trivy DB'
          inputs:
            key: 'trivy-db-cache | "$(Agent.OS)"'
            path: '$(Pipeline.Workspace)/trivydb'

        - script: |
            set -e
            mkdir -p "$(Pipeline.Workspace)/trivydb"
            curl -sL https://raw.githubusercontent.com/aquasecurity/trivy/main/contrib/install.sh | sh -
            ./bin/trivy --version

            # Update DB into our cached dir
            ./bin/trivy fs --download-db-only --cache-dir "$(Pipeline.Workspace)/trivydb" .

            # Create reports directory
            REPORT_DIR="$(System.DefaultWorkingDirectory)/trivy-reports"
            mkdir -p "$REPORT_DIR"

            # Human-readable and SARIF outputs
            ./bin/trivy fs --scanners vuln,secret,misconfig \
              --cache-dir "$(Pipeline.Workspace)/trivydb" \
              --quiet \
              --no-progress \
              --format table \
              --output "$REPORT_DIR/fs-scan.txt" \
              .

            ./bin/trivy fs --scanners vuln,secret,misconfig \
              --cache-dir "$(Pipeline.Workspace)/trivydb" \
              --quiet \
              --no-progress \
              --format sarif \
              --output "$REPORT_DIR/fs-scan.sarif" \
              . || true   # non-blocking
          displayName: 'Trivy filesystem scan (non-blocking with SARIF)'

        - task: PublishBuildArtifacts@1
          displayName: 'Publish Trivy FS reports'
          condition: always()
          inputs:
            PathtoPublish: '$(System.DefaultWorkingDirectory)/trivy-reports'
            ArtifactName: 'trivy-fs-reports'

# ========== STAGE 1: BUILD → SAVE .tar → TRIVY SCAN (gate) → PUSH ==========
- stage: Build
  displayName: 'Build, Scan (tar gate), and Push Images'
  dependsOn: CodeScan
  jobs:
    - job: BuildScanPush
      displayName: 'Backend & Frontend — Build, Trivy (tar) v$(trivy_version), Push on Pass'
      pool:
        vmImage: 'ubuntu-latest'
      steps:
        - checkout: self

        # Setup .trivyignore (for managed exceptions)
        - bash: |
            if [ ! -f .trivyignore ]; then
              echo "# Add CVEs to ignore here (use sparingly)" > .trivyignore
              echo "# Example: CVE-2024-12345" >> .trivyignore
            fi
            cp .trivyignore "$(Build.SourcesDirectory)/.trivyignore" || true
          displayName: 'Setup Trivy ignore file'

        # Build images locally (NO PUSH YET)
        - task: Docker@2
          displayName: 'Docker build — Backend (no push)'
          inputs:
            repository: 'backend'
            command: 'build'
            Dockerfile: 'backend/Dockerfile'
            buildContext: 'backend'
            tags: '$(Build.BuildId)'

        - script: |
            echo "REACT_APP_API_URL=$(backendUrl)" > frontend/.env.production
          displayName: 'Create Frontend .env file'

        - task: Docker@2
          displayName: 'Docker build — Frontend (no push)'
          inputs:
            repository: 'frontend'
            command: 'build'
            Dockerfile: 'frontend/Dockerfile'
            buildContext: 'frontend'
            tags: '$(Build.BuildId)'

        # === Save images to tarballs (no registry auth needed for scanning) ===
        - bash: |
            set -euo pipefail
            IMAGES_DIR="$(Build.SourcesDirectory)/images"
            mkdir -p "$IMAGES_DIR"

            echo "Saving backend:$(Build.BuildId) → ${IMAGES_DIR}/backend-$(Build.BuildId).tar"
            docker save "backend:$(Build.BuildId)" -o "${IMAGES_DIR}/backend-$(Build.BuildId).tar"

            echo "Saving frontend:$(Build.BuildId) → ${IMAGES_DIR}/frontend-$(Build.BuildId).tar"
            docker save "frontend:$(Build.BuildId)" -o "${IMAGES_DIR}/frontend-$(Build.BuildId).tar"
          displayName: 'Save backend & frontend images as .tar'

        # Install Trivy (pinned) + warm DB (cached)
        - task: Cache@2
          displayName: 'Cache Trivy DB'
          inputs:
            key: 'trivy-db-cache | "$(Agent.OS)"'
            path: '$(Pipeline.Workspace)/trivydb'

        - bash: |
            set -e
            echo "Installing Trivy v$(trivy_version)"
            curl -sfL https://raw.githubusercontent.com/aquasecurity/trivy/main/contrib/install.sh | sh -s -- -b ./bin v$(trivy_version)
            ./bin/trivy --version

            mkdir -p "$(Pipeline.Workspace)/trivydb"
            # Warm DB quietly
            ./bin/trivy image --download-db-only --cache-dir "$(Pipeline.Workspace)/trivydb" alpine:3.20 >/dev/null 2>&1 || true
          displayName: 'Install Trivy v$(trivy_version) & warm DB'

        # Trivy scans against tar files (gate on HIGH/CRITICAL) + SARIF artifacts
        - bash: |
            set -euo pipefail
            REPORT_DIR="$(System.DefaultWorkingDirectory)/container-security"
            mkdir -p "$REPORT_DIR"

            CACHE_DIR="$(Pipeline.Workspace)/trivydb"
            IMAGES_DIR="$(Build.SourcesDirectory)/images"
            IGNORE_FILE="$(Build.SourcesDirectory)/.trivyignore"

            # Function to scan and generate reports
            scan_image() {
              local IMAGE_NAME=$1
              local TAR_FILE="${IMAGES_DIR}/${IMAGE_NAME}-$(Build.BuildId).tar"
              
              echo "========================================"
              echo "Scanning ${IMAGE_NAME} tar (fail on HIGH/CRITICAL)..."
              echo "========================================"
              
              # Gate scan - fails on HIGH/CRITICAL
              if ! ./bin/trivy image \
                --input "${TAR_FILE}" \
                --scanners vuln,secret \
                --ignore-unfixed \
                --ignorefile "${IGNORE_FILE}" \
                --cache-dir "${CACHE_DIR}" \
                --severity HIGH,CRITICAL \
                --exit-code 1 \
                --no-progress; then
                echo "##vso[task.logissue type=error]${IMAGE_NAME} has HIGH/CRITICAL vulnerabilities!"
                return 1
              fi

              echo "✓ ${IMAGE_NAME} passed security gate"
              
              # Generate SARIF for all severities
              echo "Generating ${IMAGE_NAME} SARIF report..."
              ./bin/trivy image \
                --input "${TAR_FILE}" \
                --scanners vuln,secret \
                --ignore-unfixed \
                --ignorefile "${IGNORE_FILE}" \
                --cache-dir "${CACHE_DIR}" \
                --severity LOW,MEDIUM,HIGH,CRITICAL \
                --format sarif \
                --output "${REPORT_DIR}/${IMAGE_NAME}-trivy.sarif" \
                --no-progress
              
              # Generate human-readable report for artifacts
              echo "Generating ${IMAGE_NAME} text report..."
              ./bin/trivy image \
                --input "${TAR_FILE}" \
                --scanners vuln,secret \
                --ignore-unfixed \
                --ignorefile "${IGNORE_FILE}" \
                --cache-dir "${CACHE_DIR}" \
                --severity LOW,MEDIUM,HIGH,CRITICAL \
                --format table \
                --output "${REPORT_DIR}/${IMAGE_NAME}-trivy.txt" \
                --no-progress
              
              return 0
            }

            # Scan both images
            BACKEND_RESULT=0
            FRONTEND_RESULT=0
            
            scan_image "backend" || BACKEND_RESULT=$?
            scan_image "frontend" || FRONTEND_RESULT=$?

            # Fail if either scan failed
            if [ $BACKEND_RESULT -ne 0 ] || [ $FRONTEND_RESULT -ne 0 ]; then
              echo "##vso[task.complete result=Failed;]Security scan failed - HIGH/CRITICAL vulnerabilities found"
              exit 1
            fi

            echo "✓ All security scans passed"
          displayName: 'Trivy scan image TARS (gate) + SARIF'

        # Generate scan summary
        - bash: |
            REPORT_DIR="$(System.DefaultWorkingDirectory)/container-security"
            
            if [ -d "$REPORT_DIR" ]; then
              echo "## Security Scan Summary" > "$REPORT_DIR/summary.md"
              echo "" >> "$REPORT_DIR/summary.md"
              echo "Build ID: $(Build.BuildId)" >> "$REPORT_DIR/summary.md"
              echo "Date: $(date)" >> "$REPORT_DIR/summary.md"
              echo "" >> "$REPORT_DIR/summary.md"
              echo "### Backend Scan Results" >> "$REPORT_DIR/summary.md"
              echo '```' >> "$REPORT_DIR/summary.md"
              cat "$REPORT_DIR/backend-trivy.txt" >> "$REPORT_DIR/summary.md" 2>/dev/null || echo "No backend report" >> "$REPORT_DIR/summary.md"
              echo '```' >> "$REPORT_DIR/summary.md"
              echo "" >> "$REPORT_DIR/summary.md"
              echo "### Frontend Scan Results" >> "$REPORT_DIR/summary.md"
              echo '```' >> "$REPORT_DIR/summary.md"
              cat "$REPORT_DIR/frontend-trivy.txt" >> "$REPORT_DIR/summary.md" 2>/dev/null || echo "No frontend report" >> "$REPORT_DIR/summary.md"
              echo '```' >> "$REPORT_DIR/summary.md"
            fi
          displayName: 'Generate scan summary'
          condition: always()

        - task: PublishBuildArtifacts@1
          displayName: 'Publish Trivy image reports'
          condition: succeededOrFailed()
          inputs:
            PathtoPublish: '$(System.DefaultWorkingDirectory)/container-security'
            ArtifactName: 'trivy-image-reports'

        # If scans passed, login and PUSH both images to ACR
        - task: Docker@2
          displayName: 'Docker login to ACR'
          condition: succeeded()     # only if scans succeeded
          inputs:
            containerRegistry: '$(acrServiceConnection)'
            command: 'login'

        - bash: |
            set -euo pipefail
            echo "Tagging and pushing images to ACR..."
            
            # Tag backend
            if ! docker tag backend:$(Build.BuildId) $(acrName).azurecr.io/backend:$(Build.BuildId); then
              echo "##vso[task.logissue type=error]Failed to tag backend image"
              exit 1
            fi
            
            # Tag frontend
            if ! docker tag frontend:$(Build.BuildId) $(acrName).azurecr.io/frontend:$(Build.BuildId); then
              echo "##vso[task.logissue type=error]Failed to tag frontend image"
              exit 1
            fi

            # Push backend
            echo "Pushing backend image..."
            if ! docker push $(acrName).azurecr.io/backend:$(Build.BuildId); then
              echo "##vso[task.logissue type=error]Failed to push backend image"
              exit 1
            fi
            echo "✓ Backend image pushed successfully"
            
            # Push frontend
            echo "Pushing frontend image..."
            if ! docker push $(acrName).azurecr.io/frontend:$(Build.BuildId); then
              echo "##vso[task.logissue type=error]Failed to push frontend image"
              exit 1
            fi
            echo "✓ Frontend image pushed successfully"
            
            # Also tag and push as 'latest' for convenience
            docker tag $(acrName).azurecr.io/backend:$(Build.BuildId) $(acrName).azurecr.io/backend:latest
            docker tag $(acrName).azurecr.io/frontend:$(Build.BuildId) $(acrName).azurecr.io/frontend:latest
            docker push $(acrName).azurecr.io/backend:latest
            docker push $(acrName).azurecr.io/frontend:latest
            
            echo "✓ All images pushed successfully (including 'latest' tags)"
          displayName: 'Tag and Push images to ACR'
          condition: succeeded()

# ========== STAGE 2: TERRAFORM VALIDATION ==========
- stage: TerraformValidate
  displayName: 'Validate Terraform Configuration'
  dependsOn: []
  jobs:
    - job: Validate
      displayName: 'Terraform Validation'
      pool:
        vmImage: 'ubuntu-latest'
      steps:
        - task: TerraformInstaller@0
          displayName: 'Install Terraform'
          inputs:
            terraformVersion: 'latest'

        - bash: |
            set -e
            cd terraform
            terraform init -backend=false
            terraform fmt -recursive
            terraform validate
            echo "✓ Terraform configuration is valid"
          displayName: 'Validate Terraform Code'

# ========== STAGE 2.5: IaC Security (tfsec) ==========
- stage: IaCSecurity
  displayName: 'IaC Security (tfsec)'
  dependsOn: []
  jobs:
    - job: Tfsec
      displayName: 'tfsec scan'
      pool:
        vmImage: 'ubuntu-latest'
      steps:
        - script: |
            set -euo pipefail
            curl -s https://raw.githubusercontent.com/aquasecurity/tfsec/master/scripts/install_linux.sh | bash
            tfsec --version
            # Soft-fail so pipeline continues; report still printed to logs
            tfsec ./terraform --soft-fail
          displayName: 'tfsec scan (soft fail)'

# ========== STAGE 3: DEPLOY APPS ==========
- stage: Deploy
  displayName: 'Deploy Applications'
  dependsOn:
    - Build
    - IaCSecurity
    - CodeScan
  jobs:
    - deployment: DeployProduction
      displayName: 'Deploy to Production'
      pool:
        vmImage: 'ubuntu-latest'
      environment: 'production'
      strategy:
        runOnce:
          deploy:
            steps:
              - task: AzureWebAppContainer@1
                displayName: 'Deploy Backend App'
                inputs:
                  azureSubscription: $(azureSubscription)
                  appName: $(backendAppName)
                  containers: '$(acrName).azurecr.io/backend:$(Build.BuildId)'

              - task: AzureWebAppContainer@1
                displayName: 'Deploy Frontend App'
                inputs:
                  azureSubscription: $(azureSubscription)
                  appName: $(frontendAppName)
                  containers: '$(acrName).azurecr.io/frontend:$(Build.BuildId)'

# ========== (OPTIONAL) STAGE 4: OWASP ZAP BASELINE ==========
- stage: ZapBaseline
  displayName: 'OWASP ZAP Baseline'
  dependsOn: Deploy
  condition: succeeded()
  jobs:
    - job: Zap
      displayName: 'Run ZAP against Frontend'
      pool:
        vmImage: 'ubuntu-latest'
      steps:
        - script: |
            set -e
            docker pull ghcr.io/zaproxy/zaproxy:stable
            docker run --user root --rm \
              -v $(System.DefaultWorkingDirectory):/zap/wrk \
              ghcr.io/zaproxy/zaproxy:stable zap-baseline.py \
              -t https://$(frontendAppName).azurewebsites.net \
              -r zap_baseline_report.html \
              -x zap_baseline_report.xml \
              -m 5 \
              || true
          displayName: 'ZAP Baseline (passive)'

        - task: PublishBuildArtifacts@1
          displayName: 'Publish ZAP report'
          condition: always()
          inputs:
            PathtoPublish: '$(System.DefaultWorkingDirectory)/zap_baseline_report.html'
            ArtifactName: 'zap-report'