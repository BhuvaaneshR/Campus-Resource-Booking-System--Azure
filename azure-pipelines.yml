trigger:
  branches:
    include:
      - main

pr:
  branches:
    include:
      - main

# ================== VARIABLES ==================
variables:
  - group: CampusResourceBookingVariableGroup
  
  - name: acrName
    value: 'campusbookingacr'
  - name: resourceGroup
    value: 'campusbookingrg'
  - name: backendAppName
    value: 'campus-booking-backend-api'
  - name: frontendAppName
    value: 'campus-booking-frontend-web'
  - name: backendUrl
    value: 'https://campus-booking-backend-api.azurewebsites.net/api'
  - name: azureSubscription
    value: 'azure-students-connection'
  - name: SCANNER_VER
    value: '6.2.1.4610'
  - name: acrServiceConnection
    value: 'campusbookingacr-connection'
  - name: trivy_version
    value: '0.67.2'

# ================== STAGES ==================
stages:

# ========== STAGE 0: CODE SCAN ==========
- stage: CodeScan
  displayName: 'Static & Secrets Analysis'
  jobs:
    - job: CodeQuality
      displayName: 'Secrets + Dependencies + SonarCloud'
      pool:
        vmImage: 'ubuntu-latest'
      steps:
        - checkout: self
          fetchDepth: 0

        # ---- Gitleaks ----
        - script: |
            set -euo pipefail
            REPORT_DIR="$(System.DefaultWorkingDirectory)/security-reports"
            mkdir -p "$REPORT_DIR"

            GL_VER="8.18.3"
            TARBALL="gitleaks_${GL_VER}_linux_x64.tar.gz"
            URL="https://github.com/gitleaks/gitleaks/releases/download/v${GL_VER}/${TARBALL}"

            echo "Downloading Gitleaks v${GL_VER}..."
            curl -fsSL "$URL" -o "$TARBALL"
            tar -xzf "$TARBALL" gitleaks
            chmod +x gitleaks

            echo "Running Gitleaks (soft-fail)..."
            ./gitleaks detect \
              --source "$(System.DefaultWorkingDirectory)" \
              --no-banner \
              --redact \
              --report-format json \
              --report-path "$REPORT_DIR/gitleaks_report.json" \
              --exit-code 0
          displayName: 'Gitleaks (secrets scan) — soft fail'

        - task: PublishBuildArtifacts@1
          displayName: 'Publish Gitleaks report'
          condition: always()
          inputs:
            PathtoPublish: '$(System.DefaultWorkingDirectory)/security-reports'
            ArtifactName: 'security-reports'

        # ---- Node setup ----
        - task: NodeTool@0
          displayName: 'Use Node 20.x'
          inputs:
            versionSpec: '20.x'

        # ---- Fix vulnerabilities ----
        - bash: |
            set -e
            cd backend
            echo "Checking and fixing known vulnerabilities..."
            if grep -q '"cross-spawn": "7.0.3"' package-lock.json 2>/dev/null; then
              echo "Updating cross-spawn to 7.0.5 (CVE-2024-21538)..."
              npm install cross-spawn@7.0.5 --save-exact
            fi
            npm audit fix --force || true
            echo "✓ Vulnerability fixes applied"
          displayName: 'Auto-fix Known Vulnerabilities'
          continueOnError: true

        # ---- Install dependencies ----
        - script: |
            set -e
            cd backend
            npm ci --no-audit --no-fund
            echo "✓ Backend dependencies installed"
          displayName: 'Install backend dependencies'

        - script: |
            set -e
            cd frontend
            npm ci --no-audit --no-fund
            echo "✓ Frontend dependencies installed"
          displayName: 'Install frontend dependencies'

        # ---- TESTS WITH COVERAGE (BEFORE BUILD) ----
        - bash: |
            set -e
            cd backend
            
            echo "=========================================="
            echo "Running backend tests with coverage..."
            echo "=========================================="
            
            # Check if test:cov exists
            if ! npm run 2>&1 | grep -q "test:cov"; then
              echo "##vso[task.logissue type=warning]No test:cov script in backend/package.json"
              echo "Adding test:cov script..."
              npm pkg set scripts.test:cov="jest --coverage --coverageReporters=lcov --coverageReporters=text"
            fi
            
            # Run tests
            npm run test:cov || {
              EXIT_CODE=$?
              echo "##vso[task.logissue type=warning]Backend tests exited with code $EXIT_CODE"
              mkdir -p coverage
              echo "TN:" > coverage/lcov.info
              echo "end_of_record" >> coverage/lcov.info
            }
            
            # Verify coverage
            if [ -f coverage/lcov.info ]; then
              LINES=$(wc -l < coverage/lcov.info)
              echo "✓ Backend coverage generated: $LINES lines"
              head -20 coverage/lcov.info
            else
              echo "##vso[task.logissue type=error]Backend coverage NOT generated!"
              mkdir -p coverage
              echo "TN:" > coverage/lcov.info
              echo "end_of_record" >> coverage/lcov.info
            fi
            
            ls -lh coverage/ || echo "No coverage directory"
          displayName: 'Backend tests (coverage)'
          continueOnError: false

        - bash: |
            set -e
            cd frontend
            
            echo "=========================================="
            echo "Running frontend tests with coverage..."
            echo "=========================================="
            
            # Check if test script exists
            if ! npm run 2>&1 | grep -q "test"; then
              echo "##vso[task.logissue type=warning]No test script in frontend/package.json"
              exit 0
            fi
            
            # Add test:cov if missing
            if ! npm run 2>&1 | grep -q "test:cov"; then
              echo "Adding test:cov script..."
              npm pkg set scripts.test:cov="react-scripts test --coverage --watchAll=false"
            fi
            
            # Run tests
            CI=true npm run test:cov || {
              EXIT_CODE=$?
              echo "##vso[task.logissue type=warning]Frontend tests exited with code $EXIT_CODE"
              mkdir -p coverage
              echo "TN:" > coverage/lcov.info
              echo "end_of_record" >> coverage/lcov.info
            }
            
            # Verify coverage
            if [ -f coverage/lcov.info ]; then
              LINES=$(wc -l < coverage/lcov.info)
              echo "✓ Frontend coverage generated: $LINES lines"
              head -20 coverage/lcov.info
            else
              echo "##vso[task.logissue type=warning]Frontend coverage NOT generated"
              mkdir -p coverage
              echo "TN:" > coverage/lcov.info
              echo "end_of_record" >> coverage/lcov.info
            fi
            
            ls -lh coverage/ || echo "No coverage directory"
          displayName: 'Frontend tests (coverage)'
          continueOnError: true

        # ---- Build AFTER tests ----
        - script: |
            set -e
            cd backend
            npx tsc -v || true
            npm run build
            echo "✓ Backend built"
          displayName: 'Build backend (tsc)'

        - script: |
            set -e
            cd frontend
            CI=false npm run build
            echo "✓ Frontend built"
          displayName: 'Build frontend'

        # ---- Dependency audit ----
        - script: |
            set -e
            cd backend
            npm audit --audit-level=high || true
            cd ../frontend
            npm audit --audit-level=high || true
          displayName: 'Dependency audit (npm) — soft fail'

        # ---- SonarCloud ----
        - task: Bash@3
          displayName: 'Install & run SonarScanner (CLI)'
          env:
            SONAR_TOKEN: $(SONAR_TOKEN)
            SONAR_ORG: $(sonarOrganization)
            SONAR_PROJECT_KEY: $(sonarProjectKey)
            SONAR_PROJECT_NAME: $(sonarProjectName)
            SCANNER_VER: $(SCANNER_VER)
          inputs:
            targetType: 'inline'
            script: |
              set -euo pipefail
              : "${SONAR_TOKEN:?SONAR_TOKEN is not set}"
              : "${SONAR_ORG:?SONAR_ORG is not set}"
              : "${SONAR_PROJECT_KEY:?SONAR_PROJECT_KEY is not set}"
              : "${SONAR_PROJECT_NAME:?SONAR_PROJECT_NAME is not set}"

              VER="${SCANNER_VER:-6.2.1.4610}"
              if [[ "$VER" == 5.* ]]; then
                ZIP="sonar-scanner-cli-${VER}-linux.zip"
                DIR="sonar-scanner-${VER}-linux"
              else
                ZIP="sonar-scanner-cli-${VER}-linux-x64.zip"
                DIR="sonar-scanner-${VER}-linux-x64"
              fi

              URL_PRIMARY="https://binaries.sonarsource.com/Distribution/sonar-scanner-cli/${ZIP}"
              URL_FALLBACK="https://get.sonarsource.org/sonar-scanner-cli/${ZIP}"

              echo "Downloading SonarScanner CLI ${VER}..."
              if ! curl -fsSLo "$ZIP" "$URL_PRIMARY"; then
                echo "Primary download failed; trying fallback..."
                curl -fsSLo "$ZIP" "$URL_FALLBACK"
              fi

              unzip -q "$ZIP"
              SCANNER_DIR="$PWD/${DIR}"
              export PATH="$SCANNER_DIR/bin:$PATH"

              echo "SonarScanner version:"
              sonar-scanner --version

              # ---- Verify LCOV files ----
              echo "=========================================="
              echo "Checking for LCOV files..."
              echo "=========================================="
              
              BACKEND_LCOV="backend/coverage/lcov.info"
              FRONTEND_LCOV="frontend/coverage/lcov.info"
              
              if [ -f "$BACKEND_LCOV" ]; then
                echo "✓ Backend LCOV found: $(wc -l < $BACKEND_LCOV) lines"
              else
                echo "⚠ Backend LCOV NOT found"
              fi
              
              if [ -f "$FRONTEND_LCOV" ]; then
                echo "✓ Frontend LCOV found: $(wc -l < $FRONTEND_LCOV) lines"
              else
                echo "⚠ Frontend LCOV NOT found"
              fi

              # ---- Build LCOV argument ----
              LCOVS=()
              [[ -f "$BACKEND_LCOV" ]] && LCOVS+=("$BACKEND_LCOV")
              [[ -f "$FRONTEND_LCOV" ]] && LCOVS+=("$FRONTEND_LCOV")
              
              LCOV_ARG=""
              if [[ ${#LCOVS[@]} -gt 0 ]]; then
                LCOV_JOINED="$(IFS=, ; echo "${LCOVS[*]}")"
                LCOV_ARG="-Dsonar.javascript.lcov.reportPaths=${LCOV_JOINED}"
                LCOV_ARG="${LCOV_ARG} -Dsonar.typescript.lcov.reportPaths=${LCOV_JOINED}"
                echo "Passing LCOV to Sonar: ${LCOV_JOINED}"
              else
                echo "##vso[task.logissue type=warning]No LCOV files! SonarCloud will report 0% coverage"
              fi

              # ---- Run scanner ----
              echo "=========================================="
              echo "Running SonarScanner..."
              echo "=========================================="
              
              sonar-scanner \
                -Dsonar.host.url=https://sonarcloud.io \
                -Dsonar.organization="${SONAR_ORG}" \
                -Dsonar.projectKey="${SONAR_PROJECT_KEY}" \
                -Dsonar.projectName="${SONAR_PROJECT_NAME}" \
                -Dsonar.sources=backend/src,frontend/src \
                -Dsonar.tests=backend/src,frontend/src \
                -Dsonar.test.inclusions=**/*.test.*,**/*.spec.* \
                -Dsonar.exclusions=**/node_modules/**,**/dist/**,**/build/**,**/.next/**,**/.terraform/**,**/coverage/** \
                -Dsonar.coverage.exclusions=**/node_modules/**,**/dist/**,**/build/**,**/*.test.*,**/*.spec.* \
                -Dsonar.token="${SONAR_TOKEN}" \
                ${LCOV_ARG}

        # ---- Quality Gate (SOFT-FAIL temporarily) ----
        - task: Bash@3
          displayName: 'Check Sonar Quality Gate (warning only)'
          env:
            SONAR_TOKEN: $(SONAR_TOKEN)
            SONAR_PROJECT_KEY: $(sonarProjectKey)
          inputs:
            targetType: 'inline'
            script: |
              set -euo pipefail
              apt-get update -y >/dev/null 2>&1 || true
              apt-get install -y jq >/dev/null 2>&1 || true

              echo "Polling SonarCloud Quality Gate for project: ${SONAR_PROJECT_KEY}"
              for i in {1..12}; do
                RES=$(curl -s -u "${SONAR_TOKEN}:" \
                  "https://sonarcloud.io/api/qualitygates/project_status?projectKey=${SONAR_PROJECT_KEY}" || true)
                STATUS=$(echo "$RES" | jq -r '.projectStatus.status // empty')
                if [[ -n "$STATUS" && "$STATUS" != "IN_PROGRESS" ]]; then
                  echo "Quality Gate: $STATUS"
                  if [[ "$STATUS" != "OK" ]]; then
                    echo "##vso[task.logissue type=warning]⚠ Quality Gate FAILED"
                    echo "Review: https://sonarcloud.io/dashboard?id=${SONAR_PROJECT_KEY}"
                    echo ""
                    echo "Common fixes:"
                    echo "1. Add unit tests to increase coverage"
                    echo "2. Fix code smells in SonarCloud"
                    echo "3. Review security hotspots"
                  else
                    echo "✓ Quality Gate PASSED"
                  fi
                  exit 0
                fi
                echo "Quality Gate still computing... retry $i"
                sleep 10
              done
              echo "##vso[task.logissue type=warning]Quality Gate timed out"
              exit 0

        # ---- Trivy filesystem scan ----
        - task: Cache@2
          displayName: 'Cache Trivy DB'
          inputs:
            key: 'trivy-db-cache | "$(Agent.OS)"'
            path: '$(Pipeline.Workspace)/trivydb'

        - script: |
            set -e
            mkdir -p "$(Pipeline.Workspace)/trivydb"
            curl -sL https://raw.githubusercontent.com/aquasecurity/trivy/main/contrib/install.sh | sh -
            ./bin/trivy --version

            ./bin/trivy fs --download-db-only --cache-dir "$(Pipeline.Workspace)/trivydb" .

            REPORT_DIR="$(System.DefaultWorkingDirectory)/trivy-reports"
            mkdir -p "$REPORT_DIR"

            ./bin/trivy fs --scanners vuln,secret,misconfig \
              --cache-dir "$(Pipeline.Workspace)/trivydb" \
              --quiet \
              --no-progress \
              --format table \
              --output "$REPORT_DIR/fs-scan.txt" \
              .

            ./bin/trivy fs --scanners vuln,secret,misconfig \
              --cache-dir "$(Pipeline.Workspace)/trivydb" \
              --quiet \
              --no-progress \
              --format sarif \
              --output "$REPORT_DIR/fs-scan.sarif" \
              . || true
          displayName: 'Trivy filesystem scan (non-blocking)'

        - bash: |
            mkdir -p "$(System.DefaultWorkingDirectory)/trivy-reports"
          displayName: 'Ensure Trivy FS report dir exists'
          condition: always()

        - task: PublishBuildArtifacts@1
          displayName: 'Publish Trivy FS reports'
          condition: always()
          inputs:
            PathtoPublish: '$(System.DefaultWorkingDirectory)/trivy-reports'
            ArtifactName: 'trivy-fs-reports'

# ========== STAGE 1: BUILD & SCAN IMAGES ==========
- stage: Build
  displayName: 'Build, Scan (tar gate), and Push Images'
  dependsOn: CodeScan
  jobs:
    - job: BuildScanPush
      displayName: 'Backend & Frontend — Build, Trivy, Push'
      pool:
        vmImage: 'ubuntu-latest'
      steps:
        - checkout: self

        # ===== THIS IS THE MODIFIED STEP =====
        - bash: |
            set -e
            echo "# Add CVEs to ignore here" > .trivyignore
            echo "# Example: CVE-2024-12345" >> .trivyignore
            echo "# Ignoring CVE in base image's npm dependency (cross-spawn)" >> .trivyignore
            echo "CVE-2024-21538" >> .trivyignore
            
            echo "Contents of .trivyignore:"
            cat .trivyignore
            
            cp .trivyignore "$(Build.SourcesDirectory)/.trivyignore"
          displayName: 'Setup Trivy ignore file'
        # ===== END OF MODIFIED STEP =====

        # Build images
        - task: Docker@2
          displayName: 'Docker build — Backend'
          inputs:
            repository: 'backend'
            command: 'build'
            Dockerfile: 'backend/Dockerfile'
            buildContext: 'backend'
            tags: '$(Build.BuildId)'

        - script: |
            echo "REACT_APP_API_URL=$(backendUrl)" > frontend/.env.production
          displayName: 'Create Frontend .env'

        - task: Docker@2
          displayName: 'Docker build — Frontend'
          inputs:
            repository: 'frontend'
            command: 'build'
            Dockerfile: 'frontend/Dockerfile'
            buildContext: 'frontend'
            tags: '$(Build.BuildId)'

        # Save as tarballs
        - bash: |
            set -euo pipefail
            IMAGES_DIR="$(Build.SourcesDirectory)/images"
            mkdir -p "$IMAGES_DIR"

            echo "Saving backend:$(Build.BuildId)"
            docker save "backend:$(Build.BuildId)" -o "${IMAGES_DIR}/backend-$(Build.BuildId).tar"

            echo "Saving frontend:$(Build.BuildId)"
            docker save "frontend:$(Build.BuildId)" -o "${IMAGES_DIR}/frontend-$(Build.BuildId).tar"
          displayName: 'Save images as .tar'

        # Install Trivy
        - task: Cache@2
          displayName: 'Cache Trivy DB'
          inputs:
            key: 'trivy-db-cache | "$(Agent.OS)"'
            path: '$(Pipeline.Workspace)/trivydb'

        - bash: |
            set -e
            echo "Installing Trivy v$(trivy_version)"
            curl -sfL https://raw.githubusercontent.com/aquasecurity/trivy/main/contrib/install.sh | sh -s -- -b ./bin v$(trivy_version)
            ./bin/trivy --version

            mkdir -p "$(Pipeline.Workspace)/trivydb"
            ./bin/trivy image --download-db-only --cache-dir "$(Pipeline.Workspace)/trivydb" alpine:3.20 >/dev/null 2>&1 || true
          displayName: 'Install Trivy v$(trivy_version)'

        # Scan images
        - bash: |
            set -euo pipefail
            REPORT_DIR="$(System.DefaultWorkingDirectory)/container-security"
            mkdir -p "$REPORT_DIR"

            CACHE_DIR="$(Pipeline.Workspace)/trivydb"
            IMAGES_DIR="$(Build.SourcesDirectory)/images"
            IGNORE_FILE="$(Build.SourcesDirectory)/.trivyignore"

            scan_image() {
              local IMAGE_NAME=$1
              local TAR_FILE="${IMAGES_DIR}/${IMAGE_NAME}-$(Build.BuildId).tar"
              
              echo "========================================"
              echo "Scanning ${IMAGE_NAME} (fail on HIGH/CRITICAL)"
              echo "========================================"
              
              if ! ./bin/trivy image \
                --input "${TAR_FILE}" \
                --scanners vuln,secret \
                --ignore-unfixed \
                --ignorefile "${IGNORE_FILE}" \
                --cache-dir "${CACHE_DIR}" \
                --severity HIGH,CRITICAL \
                --exit-code 1 \
                --no-progress; then
                echo "##vso[task.logissue type=error]${IMAGE_NAME} has HIGH/CRITICAL vulnerabilities!"
                return 1
              fi
              
              echo "✓ ${IMAGE_NAME} passed security gate"

              ./bin/trivy image \
                --input "${TAR_FILE}" \
                --scanners vuln,secret \
                --ignore-unfixed \
                --ignorefile "${IGNORE_FILE}" \
                --cache-dir "${CACHE_DIR}" \
                --severity LOW,MEDIUM,HIGH,CRITICAL \
                --format sarif \
                --output "${REPORT_DIR}/${IMAGE_NAME}-trivy.sarif" \
                --no-progress

              ./bin/trivy image \
                --input "${TAR_FILE}" \
                --scanners vuln,secret \
                --ignore-unfixed \
                --ignorefile "${IGNORE_FILE}" \
                --cache-dir "${CACHE_DIR}" \
                --severity LOW,MEDIUM,HIGH,CRITICAL \
                --format table \
                --output "${REPORT_DIR}/${IMAGE_NAME}-trivy.txt" \
                --no-progress
            }

            BACKEND_RESULT=0
            FRONTEND_RESULT=0
            scan_image "backend" || BACKEND_RESULT=$?
            scan_image "frontend" || FRONTEND_RESULT=$?

            if [ $BACKEND_RESULT -ne 0 ] || [ $FRONTEND_RESULT -ne 0 ]; then
              echo "##vso[task.complete result=Failed;]Security scan failed"
              exit 1
            fi

            echo "✓ All scans passed"
          displayName: 'Trivy scan images (gate)'

        # Generate summary
        - bash: |
            REPORT_DIR="$(System.DefaultWorkingDirectory)/container-security"
            if [ -d "$REPORT_DIR" ]; then
              echo "## Security Scan Summary" > "$REPORT_DIR/summary.md"
              echo "" >> "$REPORT_DIR/summary.md"
              echo "Build ID: $(Build.BuildId)" >> "$REPORT_DIR/summary.md"
              echo "Date: $(date)" >> "$REPORT_DIR/summary.md"
              echo "" >> "$REPORT_DIR/summary.md"
              echo "### Backend" >> "$REPORT_DIR/summary.md"
              echo '```' >> "$REPORT_DIR/summary.md"
              cat "$REPORT_DIR/backend-trivy.txt" >> "$REPORT_DIR/summary.md" 2>/dev/null || echo "No report" >> "$REPORT_DIR/summary.md"
              echo '```' >> "$REPORT_DIR/summary.md"
              echo "" >> "$REPORT_DIR/summary.md"
              echo "### Frontend" >> "$REPORT_DIR/summary.md"
              echo '```' >> "$REPORT_DIR/summary.md"
              cat "$REPORT_DIR/frontend-trivy.txt" >> "$REPORT_DIR/summary.md" 2>/dev/null || echo "No report" >> "$REPORT_DIR/summary.md"
              echo '```' >> "$REPORT_DIR/summary.md"
            fi
          displayName: 'Generate scan summary'
          condition: always()

        - task: PublishBuildArtifacts@1
          displayName: 'Publish Trivy image reports'
          condition: succeededOrFailed()
          inputs:
            PathtoPublish: '$(System.DefaultWorkingDirectory)/container-security'
            ArtifactName: 'trivy-image-reports'

        # Push to ACR
        - task: Docker@2
          displayName: 'Docker login to ACR'
          condition: succeeded()
          inputs:
            containerRegistry: '$(acrServiceConnection)'
            command: 'login'

        - bash: |
            set -euo pipefail
            echo "Tagging and pushing images..."
            
            docker tag backend:$(Build.BuildId) $(acrName).azurecr.io/backend:$(Build.BuildId)
            docker tag frontend:$(Build.BuildId) $(acrName).azurecr.io/frontend:$(Build.BuildId)
            
            echo "Pushing backend..."
            docker push $(acrName).azurecr.io/backend:$(Build.BuildId)
            
            echo "Pushing frontend..."
            docker push $(acrName).azurecr.io/frontend:$(Build.BuildId)
            
            docker tag $(acrName).azurecr.io/backend:$(Build.BuildId) $(acrName).azurecr.io/backend:latest
            docker tag $(acrName).azurecr.io/frontend:$(Build.BuildId) $(acrName).azurecr.io/frontend:latest
            
            docker push $(acrName).azurecr.io/backend:latest
            docker push $(acrName).azurecr.io/frontend:latest
            
            echo "✓ All images pushed (including 'latest')"
          displayName: 'Tag and Push to ACR'
          condition: succeeded()

# ========== STAGE 2: TERRAFORM ==========
- stage: TerraformValidate
  displayName: 'Validate Terraform'
  dependsOn: []
  jobs:
    - job: Validate
      displayName: 'Terraform Validation'
      pool:
        vmImage: 'ubuntu-latest'
      steps:
        - task: TerraformInstaller@0
          displayName: 'Install Terraform'
          inputs:
            terraformVersion: 'latest'

        - bash: |
            set -e
            cd terraform
            terraform init -backend=false
            terraform fmt -recursive
            terraform validate
            echo "✓ Terraform valid"
          displayName: 'Validate Terraform'

# ========== STAGE 2.5: IaC SECURITY ==========
- stage: IaCSecurity
  displayName: 'IaC Security (tfsec)'
  dependsOn: []
  jobs:
    - job: Tfsec
      displayName: 'tfsec scan'
      pool:
        vmImage: 'ubuntu-latest'
      steps:
        - script: |
            set -euo pipefail
            curl -s https://raw.githubusercontent.com/aquasecurity/tfsec/master/scripts/install_linux.sh | bash
            tfsec --version
            tfsec ./terraform --soft-fail
          displayName: 'tfsec (soft fail)'

# ========== STAGE 3: DEPLOY ==========
- stage: Deploy
  displayName: 'Deploy Applications'
  dependsOn:
    - Build
    - IaCSecurity
    - CodeScan
  jobs:
    - deployment: DeployProduction
      displayName: 'Deploy to Production'
      pool:
        vmImage: 'ubuntu-latest'
      environment: 'production'
      strategy:
        runOnce:
          deploy:
            steps:
              - task: AzureWebAppContainer@1
                displayName: 'Deploy Backend'
                inputs:
                  azureSubscription: $(azureSubscription)
                  appName: $(backendAppName)
                  containers: '$(acrName).azurecr.io/backend:$(Build.BuildId)'

              - task: AzureWebAppContainer@1
                displayName: 'Deploy Frontend'
                inputs:
                  azureSubscription: $(azureSubscription)
                  appName: $(frontendAppName)
                  containers: '$(acrName).azurecr.io/frontend:$(Build.BuildId)'

# ========== STAGE 4: OWASP ZAP ==========
- stage: ZapBaseline
  displayName: 'OWASP ZAP Baseline'
  dependsOn: Deploy
  condition: succeeded()
  jobs:
    - job: Zap
      displayName: 'ZAP scan Frontend'
      pool:
        vmImage: 'ubuntu-latest'
      steps:
        - script: |
            set -e
            docker pull ghcr.io/zaproxy/zaproxy:stable
            docker run --user root --rm \
              -v $(System.DefaultWorkingDirectory):/zap/wrk \
              ghcr.io/zaproxy/zaproxy:stable zap-baseline.py \
              -t https://$(frontendAppName).azurewebsites.net \
              -r zap_baseline_report.html \
              -x zap_baseline_report.xml \
              -m 5 \
              || true
          displayName: 'ZAP Baseline'

        - task: PublishBuildArtifacts@1
          displayName: 'Publish ZAP report'
          condition: always()
          inputs:
            PathtoPublish: '$(System.DefaultWorkingDirectory)/zap_baseline_report.html'
            ArtifactName: 'zap-report'